<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title></title>
 <link href="http://lionel-.github.io" rel="self"/>
 <link href="http://lionel-.github.io"/>
 <updated>2016-09-27T13:05:58+02:00</updated>
 <id>http://lionel-.github.io</id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>The future of R syntax?</title>
   <link href="http://lionel-.github.io/2016/02/15/ideas-for-an-updated-r-syntax"/>
   <updated>2016-02-15T00:00:00+01:00</updated>
   <id>http://lionel-.github.io/2016/02/15/ideas-for-an-updated-r-syntax</id>
   <content type="html">&lt;p&gt;Following &lt;a href=&quot;http://blog.r-enthusiasts.com/2014/08/22/pro-grammar-and-devel-hoper/&quot;&gt;Romain Fran√ßois&amp;#39;s
example&lt;/a&gt;,
I spent last week playing with the definition of the R grammar. I
focused on four changes that I think would improve existing R idioms:
creating lists with bare square brackets; a compact lambda notation;
labelled blocks of code; and of course implementing natively the pipe
operator. While none of these changes are strictly necessary, they
make the language more comfortable to use and nicer to look at. I
provide working implementations for all of them in the &lt;code&gt;brackets&lt;/code&gt;,
&lt;code&gt;brackets-lambda&lt;/code&gt;, &lt;code&gt;labelled&lt;/code&gt; and &lt;code&gt;pipe&lt;/code&gt; branches at
&lt;a href=&quot;https://github.com/lionel-/r-source&quot;&gt;https://github.com/lionel-/r-source&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Bare Square Brackets&lt;/h2&gt;

&lt;p&gt;Advanced treatments of R programming stress that R is a functional
language. This essentially means that functions are first-class
citizens and that you can pass them as arguments to other
functions. This makes it possible to have the apply family of
functions in base R or the map family in purrr. By the same token,
this makes lists extremely useful in R. They can contain any kind of
objects and you can use functional programming techniques to
manipulate them with expressive idioms. In addition, since lists
elements are associated with names, they can directly map to the
arguments of a function call via &lt;code&gt;do.call()&lt;/code&gt; or &lt;code&gt;purrr::invoke()&lt;/code&gt;,
another key idiom of functional programming in R.&lt;/p&gt;

&lt;p&gt;Despite their importance in the R language, lists do not benefit from
as much syntax sugar as in other languages. Hence my &lt;a href=&quot;https://github.com/lionel-/r-source/compare/bd712b1...fa0222cc&quot;&gt;first change to
the R syntax&lt;/a&gt;:
creating lists with bare square brackets:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;letters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [[1]]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] 3&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [[2]]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] 4&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [[3]]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt;  [1] &amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot; &amp;quot;e&amp;quot; &amp;quot;f&amp;quot; &amp;quot;g&amp;quot; &amp;quot;h&amp;quot; &amp;quot;i&amp;quot; &amp;quot;j&amp;quot; &amp;quot;k&amp;quot; &amp;quot;l&amp;quot; &amp;quot;m&amp;quot; &amp;quot;n&amp;quot; &amp;quot;o&amp;quot; &amp;quot;p&amp;quot; &amp;quot;q&amp;quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [18] &amp;quot;r&amp;quot; &amp;quot;s&amp;quot; &amp;quot;t&amp;quot; &amp;quot;u&amp;quot; &amp;quot;v&amp;quot; &amp;quot;w&amp;quot; &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;z&amp;quot;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;letters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; map_lgl&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;is.double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1]  TRUE  TRUE FALSE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This can greatly improve code clarity. Compare dense nested list
constructs such as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to the much lighter and cleaner&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An important use case that would also benefit from this syntax is when
a function needs some additional arguments in the form of a
list. Think of the &lt;code&gt;contrasts&lt;/code&gt; argument of &lt;code&gt;lm()&lt;/code&gt; or the &lt;code&gt;args&lt;/code&gt;
argument of ggplot2&amp;#39;s &lt;code&gt;stat_function()&lt;/code&gt;. They both involve passing a
list of arguments, which bloats the calls and makes scripts heavier to
read. The bare brackets notation is a bit lighter:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;mtcars&lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;cyl &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;as.factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;mtcars&lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;cyl&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Specific contrast for the predictor `cyl`&lt;/span&gt;
lm&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;disp &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt; cyl &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; am&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; data &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; mtcars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; contrasts &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;cyl &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; contr.sum&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I also have a feeling that bare brackets may be useful to come up with
clean creative syntax in DSLs. Like any syntax construct in R, the
square brackets are represented as a plain text function. For example
instead of &lt;code&gt;mtcars[[&amp;quot;cyl&amp;quot;]]&lt;/code&gt;, you can write &lt;code&gt;
`[[`(mtcars, &amp;quot;cyl&amp;quot;)&lt;/code&gt;. The string for bare brackets is &lt;code&gt;`[]&lt;/code&gt; ` and
allows you to redefine its functionality as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;sb&quot;&gt;`[]`&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] &amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By the same token, DSLs could capture bare brackets and give them some
specific meaning.&lt;/p&gt;

&lt;p&gt;Finally, some additional syntax rule could allow for list
comprehensions by looking up the &lt;code&gt;for&lt;/code&gt; keyword inside bare
brackets. This would enable this kind of python-style code:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# List comprehension:&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; mtcars&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Equivalent to the following map:&lt;/span&gt;
mtcars &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; map&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However I think that&amp;#39;s going a step too far as the functional version
is much more R-like.&lt;/p&gt;

&lt;h2&gt;Lambda Notation&lt;/h2&gt;

&lt;p&gt;In R functions can be created, given names and passed around. But a
common idiom involves creating anonymous functions (lambda functions)
on the fly. As the full syntax for defining a function can be
cumbersome in those situations, many languages such as
&lt;a href=&quot;http://docs.scala-lang.org/tutorials/tour/anonymous-function-syntax.html&quot;&gt;Scala&lt;/a&gt;,
&lt;a href=&quot;https://wiki.haskell.org/Anonymous_function&quot;&gt;Haskell&lt;/a&gt;,
&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd233201.aspx&quot;&gt;F-Sharp&lt;/a&gt;,
&lt;a href=&quot;https://docs.python.org/2/reference/expressions.html#lambda&quot;&gt;Python&lt;/a&gt;,
and even &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/lambda&quot;&gt;C++&lt;/a&gt;
support a compact notation for creating lambdas. Given the importance
of lambda functions in R (as in the &lt;code&gt;apply&lt;/code&gt; family of functions), it
would be particularly nice to provide an elegant notation for creating
them. The &lt;a href=&quot;https://github.com/lionel-/r-source/compare/fa0222c...18998a28#diff-eab64d2b802078a8639bc3182307d6b5&quot;&gt;second syntax
update&lt;/a&gt;,
relies on the bare square brackets notation for that purpose.&lt;/p&gt;

&lt;p&gt;The notation is based on the rightward assignment &lt;code&gt;-&amp;gt;&lt;/code&gt;, an operator
that is barely used in practice because it&amp;#39;s a bit confusing. Bare
square brackets followed by &lt;code&gt;-&amp;gt;&lt;/code&gt; followed by any R expression create a
function in place:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; x
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [x] -&amp;gt; 3 * x&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; x&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] 15&lt;/span&gt;

&lt;span class=&quot;kp&quot;&gt;lapply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;col &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; $speed&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] 0.03246753&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; $dist&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] 0.05583993&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This notation supports variadic lambdas by supplying dots:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;variadic &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  sum &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;..1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;..2&lt;/span&gt;
  sum &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

variadic&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# [1] 21&lt;/span&gt;


variadic2 &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

variadic2&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# [1] 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thanks to operator precedence and the left associativity of &lt;code&gt;-&amp;gt;&lt;/code&gt;,
usual R rules for assignment apply. The following snippet assigns the
lambda first to &lt;code&gt;byproduct&lt;/code&gt;, then to &lt;code&gt;fun&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;fun &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; byproduct
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Labelled Blocks&lt;/h2&gt;

&lt;p&gt;In R, code is data. When a function is called, its arguments are
usually evaluated and assigned to the parameter. But functions can
also request to see the code used to compute that value in the form of
a &lt;a href=&quot;http://adv-r.had.co.nz/Expressions.html&quot;&gt;quoted expression&lt;/a&gt;. This
capacity to capture code is invaluable to creating intuitive
sublanguages like &lt;code&gt;dplyr&lt;/code&gt; or &lt;code&gt;ggplot2&lt;/code&gt;. The &lt;a href=&quot;https://github.com/lionel-/r-source/commit/e959f91b97b31de93781befc972952b8eb1a38a4&quot;&gt;third
change&lt;/a&gt;
that I introduce to R&amp;#39;s syntax focuses on the subset of DSLs that
manipulate blocks of code, such as the great &lt;code&gt;testthat&lt;/code&gt; package.&lt;/p&gt;

&lt;p&gt;Currently, blocks of code are passed to a function via curly brackets:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;test_that&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;my code works&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Wouldn&amp;#39;t it be nicer to have the same syntax as function definitions,
for loops and if-else branches? That&amp;#39;s the purpose of this second syntax
change. It allows you to write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;test_that&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;my code works&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That&amp;#39;s a fairly cosmetic change and admittedly not earth
shattering. However, it makes the language a bit nicer and
easthetically pleasing. This syntax would be a particulary nice for
alternative ways of defining functions. For example, the type-checked
functions of the
&lt;a href=&quot;https://github.com/smbache/ensurer/blob/master/R/function_.R&quot;&gt;&lt;code&gt;ensurer&lt;/code&gt; package&lt;/a&gt;
would look a bit more natural:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;type_checked &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; function_&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;a &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; b &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;character&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  some_call&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  other_call&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To make this work in the most R-like possible way, I decided to let
the function call be any expression. This mirrors the syntax of
regular function calls which may be embedded in arbitrary ways. In the
following snippet, &lt;code&gt;russian_dolls()&lt;/code&gt; returns a list whose first
element is a function that returns a function that returns 3:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;russian_dolls&lt;span class=&quot;p&quot;&gt;()[[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]()()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This kind of constructs are also possible with labelled blocks:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;my_block&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]()()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  code
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The only requirement is that the end result of the expression be a
function that accepts at least one argument (the block of code). This
means that &lt;code&gt;test_that()&lt;/code&gt; would be implemented in this way:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;test_that &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;desc&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;force&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;desc&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;code&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    test_code&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;desc&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;substitute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;code&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; env &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;parent.frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;kp&quot;&gt;invisible&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;test_that&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;my code works&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  check_equal&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;A&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; B&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  check_identical&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;C&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; D&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Is actually equivalent to&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;code&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    test_code&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;desc&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;substitute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;code&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; env &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;parent.frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;kp&quot;&gt;invisible&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;})({&lt;/span&gt;
   check_equal&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;A&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; B&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   check_identical&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;C&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; D&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In addition to expressions, simple labels are of course allowed:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;label &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  line1
  line2
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For instance this would fit well with the
&lt;a href=&quot;http://r-nimble.org/examples-2&quot;&gt;Nimble DSL&lt;/a&gt; for specifying Bugs
models. Simple labels work a bit differently than expressions
though. Here, instead of looking for a function named &lt;code&gt;label&lt;/code&gt;, the
parser will look for &lt;code&gt;label{}&lt;/code&gt;. This makes it possible to use the same
identifier for a regular function call and a labelled block:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;label &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;sb&quot;&gt;`label{}`&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;code&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;

label&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] 3&lt;/span&gt;

label &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  anything
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] 4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, note that contrary to other labelled blocks such as function
definitions, the opening curly bracket must be on the same line as
its identifier. Otherwise it would be ambiguous whether we have a
labelled block or two expressions separated by a newline:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;label
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;code&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This slight inconsistency is the price to pay for that syntax
extension.&lt;/p&gt;

&lt;h2&gt;Piping Operator&lt;/h2&gt;

&lt;p&gt;This is of course the syntax update that many people of the R
community are waiting for. A native piping operator. Some of the most
popular R packages are based on piped interface: &lt;code&gt;dplyr&lt;/code&gt; who
popularised &lt;code&gt;magrittr&lt;/code&gt;, but also &lt;code&gt;ggplot2&lt;/code&gt;. The latter uses a custom
non-functional pipeline by overloading the &lt;code&gt;+&lt;/code&gt; operator but the sequel
&lt;code&gt;ggvis&lt;/code&gt; does rely on functional piping. I provide for testing purposes
&lt;a href=&quot;https://github.com/lionel-/r-source/compare/7e2a6a8...2c774a17f4&quot;&gt;two versions&lt;/a&gt;
of a native pipe operator, &lt;code&gt;|&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Given the popularity of the pipe, having native support for it in R&amp;#39;s
syntax would be a huge progress. Besides the obvious aesthetic concern
(though you do get accustomed to &lt;code&gt;%&amp;gt;%&lt;/code&gt; with time) native handling of
the pipe would improve error recovery. Here is how a traceback
currently looks like with magrittr&amp;#39;s pipe:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;fail &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;fail&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
mtcars &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;lapply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;fail&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;unlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; Error in FUN(X[[i]], ...) (from #1) : fail&lt;/span&gt;

&lt;span class=&quot;kp&quot;&gt;traceback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 15: stop(&amp;quot;fail&amp;quot;) at #1&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 14: FUN(X[[i]], ...)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 13: lapply(., fail)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 12: function_list[[1L]](value)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 11: unlist(.)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 10: function_list[[1L]](value)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 9: withVisible(function_list[[1L]](value))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 8: freduce(value, `_function_list`)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 7: Recall(function_list[[1L]](value), function_list[-1L])&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 6: freduce(value, `_function_list`)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 5: `_fseq`(`_lhs`)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 4: eval(expr, envir, enclos)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 3: eval(quote(`_fseq`(`_lhs`)), env, env)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 2: withVisible(eval(quote(`_fseq`(`_lhs`)), env, env))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 1: mtcars %&amp;gt;% lapply(fail) %&amp;gt;% unlist()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This ugly traceback includes all the steps where magrittr manipulates
the unevaluated code. Here is the same traceback with native support:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;mtcars &lt;span class=&quot;o&quot;&gt;|&amp;gt;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;lapply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;fail&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&amp;gt;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;unlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; Error in FUN(X[[i]], ...) : fail&lt;/span&gt;

&lt;span class=&quot;kp&quot;&gt;traceback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 4: stop(&amp;quot;fail&amp;quot;) at #1&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 3: FUN(X[[i]], ...)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 2: lapply(mtcars, fail)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; 1: unlist(mtcars |&amp;gt; lapply(fail))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;_&lt;/code&gt; character is also legalised so it can become the placeholder
in pipelines. The same rules as with magrittr&amp;#39;s placeholder apply:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;mtcars &lt;span class=&quot;o&quot;&gt;|&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; _&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;identical&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;mtcars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; mtcars&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] TRUE&lt;/span&gt;

mtcars &lt;span class=&quot;o&quot;&gt;|&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; _&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;identical&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;mtcars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;mtcars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; mtcars&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&amp;gt; [1] TRUE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I actually provide two implementations of the pipe. The first creates
a classic binary operator that calls a special primitive
function. These are a class of core R function that do not evaluate
their arguments, which allows them to manipulate quoted code before
evaluation.&lt;/p&gt;

&lt;p&gt;The second implementation, called by the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator, directly
manipulate the parse tree. This means that you cannot redefine &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. R
will always transform the expression &lt;code&gt;object &amp;gt;&amp;gt; call()&lt;/code&gt; to
&lt;code&gt;call(object)&lt;/code&gt; and you&amp;#39;ll never get a chance to call the operator
manually with prefix notation. Such syntax transformation applies to a
few operators in R, like the rightward assignment op &lt;code&gt;-&amp;gt;&lt;/code&gt; or the
double starred exponentiation &lt;code&gt;**&lt;/code&gt;. By contrast, the first operator
&lt;code&gt;|&amp;gt;&lt;/code&gt; does accept to be redefined and called with prefix notation.&lt;/p&gt;

&lt;p&gt;I think the first implementation is more natural in the R language and
consistent with most operators. On the other hand, manipulating the
parse tree ensures that the placeholder &lt;code&gt;_&lt;/code&gt; will always act
consistently as a shortcut for the LHS. This would avoid the conflicts
that arise with the &lt;code&gt;.&lt;/code&gt; placeholder which is currently used for
different conflicting purposes in dplyr, magrittr and purrr. Thus
there are pros and cons for both approaches.&lt;/p&gt;

&lt;h2&gt;Could this get into R Core?&lt;/h2&gt;

&lt;p&gt;R Core has gotten the reputation of being a bit conservative, which is
only fair considering the responsibility that weighs on their
shoulders.&lt;/p&gt;

&lt;p&gt;I think that contrarily to proposals for integrating optional type
checking in the syntax, all four of these syntax changes clearly fit
the spirit of R as a dynamic, functional language. When it makes
sense, they can be manipulated like first class citizens through
prefix notation like other language constructs. They shouldn&amp;#39;t disturb
any existing R code and they improve currently used R idioms rather
than invent new ones. So I think there is a chance that R core could
consider some of them.&lt;/p&gt;

&lt;p&gt;More testing is needed to assess the consequences in terms of
performance and backward compatibility, though I didn&amp;#39;t find any
problem from my limited testing. One point of contention might be that
the bare brackets and labelled blocks increase the number of
shift-reduce conflicts during parser generation. I guess many of those
could be fixed by refactoring the grammar a bit, or adding precedence
and association directives to some production rules. But core members
will probably feel a bit nervous about applying non-trivial changes to
that fundamental part of the R code that basically didn&amp;#39;t change since
the &lt;a href=&quot;https://github.com/wch/r-source/blob/fa44a2cd83a81ecbccd6545895955cff7f719156/src/main/gram.y&quot;&gt;first available revision in
1997&lt;/a&gt;.
It&amp;#39;s probably ok to ignore these conflicts however. There&amp;#39;s currently
81 of them and Bison, the parser generator, seems to be doing a very
good job of automatically resolving the ambiguities.&lt;/p&gt;

&lt;p&gt;My plan is to get community feedback on Twitter before proposing the
changes to R core. In case they are interested in some them, I&amp;#39;ll run
a comprehensive test on CRAN packages to make sure that the new syntax
doesn&amp;#39;t break anything.&lt;/p&gt;

&lt;p&gt;So, could R 4.0 look like this?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt; test_that&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;new syntax works&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

   data &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;mtcars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; mtcars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   expected &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;lapply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;is.list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;is.double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

   mtcars &lt;span class=&quot;o&quot;&gt;|&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; _&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&amp;gt;&lt;/span&gt;
     map&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;is.list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;is.double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&amp;gt;&lt;/span&gt;
     check_equal&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;expected&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Using purrr with dplyr</title>
   <link href="http://lionel-.github.io/2015/10/08/using-purrr-with-dplyr"/>
   <updated>2015-10-08T00:00:00+02:00</updated>
   <id>http://lionel-.github.io/2015/10/08/using-purrr-with-dplyr</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Most of the data frame functions in purrr have been
deprecated in favour of a new family of functions in dplyr. The intent
is to better separate the responsibilities of packages in the
tidyverse. First of all &lt;code&gt;map()&lt;/code&gt; now always returns a list. It no
longer preserves the data frame type. Secondly, all slice- and
rows-based functions are now deprecated. Mapping a column is now
handled by the colwise family of dplyr functions,
e.g. &lt;code&gt;dplyr::mutate_all()&lt;/code&gt;, &lt;code&gt;dplyr::summarise_if()&lt;/code&gt;, etc. Unlike the
&lt;code&gt;_each()&lt;/code&gt; variants which only accept expressions wrapped in &lt;code&gt;funs()&lt;/code&gt;,
the new colwise family accepts regular functions as well as additional
arguments to be passed on. The syntax is thus pretty close to purrr&amp;#39;s:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;mtcars &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; group_by&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;cyl&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; mutate_all&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; center &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;/Update&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;purrr&lt;/code&gt; was finally
&lt;a href=&quot;http://blog.rstudio.org/2015/09/29/purrr-0-1-0/&quot;&gt;released&lt;/a&gt; on CRAN
last week. This package is focused on working with lists (and data
frames by the same token). However it is not a DSL for lists in the
way dplyr is a DSL for data frames. It aims at creating a &amp;quot;better
standard lib&amp;quot; focused on functional programming. Purrr should feel
like R programming and bring out the elegance of the language. That
said, purrr can be a nice companion to your dplyr pipelines especially
when you need to apply a function to many columns. In this post I show
how purrr&amp;#39;s functional tools can be applied to a dplyr workflow.&lt;/p&gt;

&lt;p&gt;dplyr provides &lt;code&gt;mutate_each()&lt;/code&gt; and &lt;code&gt;summarise_each()&lt;/code&gt; for the purpose
of mapping functions but I find that they are not as easy to use as
the rest of the interface. This is mostly because there is no easy way
to map a function to parts of your data frame. It&amp;#39;s all columns or
nothing. Also, they introduce a custom notation for lambda functions that
can be a bit cumbersome. These are two areas where purrr shines in
comparison. And since the interface has been designed with pipes in
mind, purrr&amp;#39;s functions integrate dplyr pipelines quite well.&lt;/p&gt;

&lt;h2&gt;Mapping to columns conditionally&lt;/h2&gt;

&lt;p&gt;One of my favourite functions in purrr is &lt;code&gt;map_if()&lt;/code&gt;. It accepts a
predicate function or a logical vector that specifies which columns
should be mapped with a function. This makes it easy to apply a
function conditionally, as in the following snippet where we transform
all factors to a character vector:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;kn&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;purrr&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;dplyr&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
data&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;diamonds&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; package &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;ggplot2&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

diamonds &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; map_if&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;is.factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;as.character&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; str&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#&amp;gt; Classes &amp;#39;tbl_df&amp;#39;, &amp;#39;tbl&amp;#39; and &amp;#39;data.frame&amp;#39;:    53940 obs. of  10 variables:
#&amp;gt;  $ carat  : num  0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...
#&amp;gt;  $ cut    : chr  &amp;quot;Ideal&amp;quot; &amp;quot;Premium&amp;quot; &amp;quot;Good&amp;quot; &amp;quot;Premium&amp;quot; ...
#&amp;gt;  $ color  : chr  &amp;quot;E&amp;quot; &amp;quot;E&amp;quot; &amp;quot;E&amp;quot; &amp;quot;I&amp;quot; ...
#&amp;gt;  $ clarity: chr  &amp;quot;SI2&amp;quot; &amp;quot;SI1&amp;quot; &amp;quot;VS1&amp;quot; &amp;quot;VS2&amp;quot; ...
#&amp;gt;  $ depth  : num  61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...
#&amp;gt;  $ table  : num  55 61 65 58 58 57 57 55 61 61 ...
#&amp;gt;  $ price  : int  326 326 327 334 335 336 336 337 337 338 ...
#&amp;gt;  $ x      : num  3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...
#&amp;gt;  $ y      : num  3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...
#&amp;gt;  $ z      : num  2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Mapping to specific columns&lt;/h2&gt;

&lt;p&gt;While cleaning a dataset, it is common to apply the same
transformation to many variables. For example, reversing a scale or
shifting it to zero. Instead of writing a long &lt;code&gt;mutate()&lt;/code&gt; call with
those transformations, I prefer to do it in one go.&lt;/p&gt;

&lt;p&gt;This can be done with &lt;code&gt;map_at()&lt;/code&gt; which takes a vector of column
positions or column names. For example, let&amp;#39;s assume you have written
two functions &lt;code&gt;reverse_scale()&lt;/code&gt; and &lt;code&gt;shift_to_zero()&lt;/code&gt; that should be
applied to specific variables. You record those variables in character
vectors just before starting the dplyr/purrr pipeline, and then add
the relevant &lt;code&gt;map_at()&lt;/code&gt; calls.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;to_reverse_vars &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;cyl&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;am&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;vs&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;gear&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;carb&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
to_zero_vars &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;cyl&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;gear&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;carb&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

mtcars &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt;
  select&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;disp&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt;
  map_at&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;to_reverse_vars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; reverse_scale&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt;
  map_at&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;to_zero_vars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; shift_to_zero&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Expanding one column to many with lmap()&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lmap()&lt;/code&gt;&amp;#39;s story starts with
&lt;a href=&quot;https://twitter.com/hadleywickham/status/428157972733108224&quot;&gt;the mysterious tweet&lt;/a&gt;
and
&lt;a href=&quot;https://twitter.com/hadleywickham/status/428161355502202881&quot;&gt;the gist&lt;/a&gt;
that show up when you google &amp;quot;hadley monads&amp;quot;. While I&amp;#39;m not sure I
really understand how it is monadic, &lt;code&gt;lmap()&lt;/code&gt; is quite useful
to extend a data frame without having to deal with binds, merges or
having to define new column names.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s say you have a numeric variable that you want to discretise for
data exploration or modelling (for example, to use as pivot in a
ggplot facetting). There are several ways to cut a vector into
pieces. Ideally, the cutpoints should be derived from theory, but it&amp;#39;s
often not possible or too time consuming to do so. In this case, I
like to create different categorisations and check if the results are
consistent (and investigate when they are not). Let&amp;#39;s define two
cutting functions, one that tries to create categories with equal
sample sizes while the other just uses equal ranges to determine
cutpoints.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;cut_equal_sizes &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; n &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  ggplot2&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;cut_number&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; n&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

cut_equal_ranges &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; n &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;cut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; n&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; include.lowest &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;#39;d be nice to &amp;quot;grow&amp;quot; the data frame at specific numeric columns in
such a way that that two news discretised variables appear just next
to them with appropriate column names. &lt;code&gt;lmap()&lt;/code&gt; is adapted to this
because instead of applying a function to the vectors contained in a
data frame, it applies it to subsets of size 1 of that data
frame. This has several advantages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;You get the name of the vector as an attribute of the enclosing data
frame.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The usual mapping tools work on columns, so when you return a list
or a data frame of vectors, they&amp;#39;ll try to stick these inside a
list-column, which is not what we want in this case. By comparison,
&lt;code&gt;lmap()&lt;/code&gt; gives a data frame to a function and expects a data frame
in return and has no problem dealing with it when it has more than
one column.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;#39;s write a function to be mapped in such a way. This function
doesn&amp;#39;t work with vectors but with vectors enclosed in a data
frame. It takes and returns a data frame.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;cut_categories &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; n &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# Record the name of the enclosed vector&lt;/span&gt;
  name &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# Create the new columns&lt;/span&gt;
  x&lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;cat_n &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; cut_equal_sizes&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt; n&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  x&lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;cat_r &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; cut_equal_ranges&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt; n&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# Adjusting the names of the new columns&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;paste0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;_&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; n&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

  x
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we just add a &lt;code&gt;lmap()&lt;/code&gt; call to our data cleaning pipeline:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;to_discretise_vars &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;mpg&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;disp&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;drat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;wt&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;qsec&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

mtcars &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; lmap_at&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;to_discretise_vars&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; cut_categories&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt; str&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#&amp;gt; Classes &amp;#39;tbl_df&amp;#39;, &amp;#39;tbl&amp;#39; and &amp;#39;data.frame&amp;#39;:    32 obs. of  21 variables:
#&amp;gt;  $ mpg        : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
#&amp;gt;  $ mpg_3cat_n : Factor w/ 3 levels &amp;quot;[10.4,16.7]&amp;quot;,..: 2 2 3 2 2 2 1 3 3 2 ...
#&amp;gt;  $ mpg_3cat_r : Factor w/ 3 levels &amp;quot;[10.4,18.2]&amp;quot;,..: 2 2 2 2 2 1 1 2 2 2 ...
#&amp;gt;  $ cyl        : num  6 6 4 6 8 6 8 4 4 6 ...
#&amp;gt;  $ disp       : num  160 160 108 258 360 ...
#&amp;gt;  $ disp_3cat_n: Factor w/ 3 levels &amp;quot;[71.1,146]&amp;quot;,&amp;quot;(146,293]&amp;quot;,..: 2 2 1 2 3 2 3 2 1 2 ...
#&amp;gt;  $ disp_3cat_r: Factor w/ 3 levels &amp;quot;[70.7,205]&amp;quot;,&amp;quot;(205,338]&amp;quot;,..: 1 1 1 2 3 2 3 1 1 1 ...
#&amp;gt;  $ hp         : num  110 110 93 110 175 105 245 62 95 123 ...
#&amp;gt;  $ drat       : num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
#&amp;gt;  $ drat_3cat_n: Factor w/ 3 levels &amp;quot;[2.76,3.17]&amp;quot;,..: 2 2 2 1 1 1 2 2 3 3 ...
#&amp;gt;  $ drat_3cat_r: Factor w/ 3 levels &amp;quot;[2.76,3.48]&amp;quot;,..: 2 2 2 1 1 1 1 2 2 2 ...
#&amp;gt;  $ wt         : num  2.62 2.88 2.32 3.21 3.44 ...
#&amp;gt;  $ wt_3cat_n  : Factor w/ 3 levels &amp;quot;[1.51,2.81]&amp;quot;,..: 1 2 1 2 2 2 3 2 2 2 ...
#&amp;gt;  $ wt_3cat_r  : Factor w/ 3 levels &amp;quot;[1.51,2.82]&amp;quot;,..: 1 2 1 2 2 2 2 2 2 2 ...
#&amp;gt;  $ qsec       : num  16.5 17 18.6 19.4 17 ...
#&amp;gt;  $ qsec_3cat_n: Factor w/ 3 levels &amp;quot;[14.5,17]&amp;quot;,&amp;quot;(17,18.6]&amp;quot;,..: 1 1 3 3 1 3 1 3 3 2 ...
#&amp;gt;  $ qsec_3cat_r: Factor w/ 3 levels &amp;quot;[14.5,17.3]&amp;quot;,..: 1 1 2 2 1 3 1 2 3 2 ...
#&amp;gt;  $ vs         : num  0 0 1 1 0 1 0 1 1 1 ...
#&amp;gt;  $ am         : num  1 1 1 0 0 0 0 0 0 0 ...
#&amp;gt;  $ gear       : num  4 4 4 3 3 3 3 4 4 4 ...
#&amp;gt;  $ carb       : num  4 4 1 1 2 1 4 2 2 4 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The data frame comes out of the pipeline with the new discretised
variables nicely arranged and named.&lt;/p&gt;

&lt;h2&gt;Mapping a function within groups&lt;/h2&gt;

&lt;p&gt;purrr is also able to deal with dplyr groupings. The groups can be
defined with either &lt;code&gt;dplyr::by_group()&lt;/code&gt; or &lt;code&gt;purrr::slice_rows()&lt;/code&gt;. To
apply a function to all columns within groups, just combine a mapping
function with the &lt;code&gt;by_slice()&lt;/code&gt; adverb:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;mtcars &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt;
  slice_rows&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;cyl&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&amp;gt;%&lt;/span&gt;
  by_slice&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;map&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;.&lt;/span&gt;x &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;.&lt;/span&gt;x&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Starting a blog</title>
   <link href="http://lionel-.github.io/2015/10/05/starting-a-blog"/>
   <updated>2015-10-05T00:00:00+02:00</updated>
   <id>http://lionel-.github.io/2015/10/05/starting-a-blog</id>
   <content type="html">&lt;p&gt;I am starting this blog mostly to share Emacs tricks and perhaps talk
about some R projects of mine. As is often the case, this blog will
serve as a way of keeping trace of how I solved a problem or where I
found a solution.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s the first one: if you start a blog and like clean and
minimalist layouts and workflows, it&amp;#39;s probably best to ignore
high-level wrappers like &lt;a href=&quot;http://jekyllbootstrap.com&quot;&gt;JB&lt;/a&gt;. Just bite
the bullet and learn pure Jekyll. I started with JB but ended up
removing all of it layer after layer. The only bit I still use is the
rakefile to create new posts, but this is trivial stuff.&lt;/p&gt;

&lt;p&gt;Also, I quickly gave up on the idea of having Github generate the
pages. Most Jekyll plugins are not supported (such as generators of
tag pages) and it&amp;#39;s easy enough to build the pages locally and push
the html to your Github repository.&lt;/p&gt;

&lt;!-- 
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;defun&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;neat-R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;inferior-R-args&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;--vanilla&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt;         &lt;span class=&quot;nv&quot;&gt;ess-R-post-run-hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;add-hook&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&amp;#39;ess-R-post-run-hook&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt;               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt;                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ess-send-input-silently&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;.libPaths(&amp;#39;~/Dropbox/Applications/R&amp;#39;)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt;                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ess-send-input-silently&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;options(repos = c(CRAN = &amp;#39;http://cran.rstudio.com/&amp;#39;))&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;&amp;lt;!--&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 --&gt;

&lt;!-- 
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; blog_dir &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;~/Dropbox/Projects/Blog/&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; fig_dir &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;paste0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;assets/figures/&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`_post_path`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; fig_dir_full &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;paste0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;blog_dir&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; fig_dir&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;file.exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;fig_dir_full&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;   &lt;span class=&quot;kp&quot;&gt;dir.create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;fig_dir_full&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; knitr&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;render_jekyll&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;pygments&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; knitr&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;opts_knit&lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;set&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;   base.url &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;   base.dir &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; blog_dir&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;   width &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; knitr&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;opts_chunk&lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;set&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;   fig.path &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;paste0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;fig_dir&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;   fig.width &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;   fig.height &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;   dev &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;svg&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 --&gt;
</content>
 </entry>
 
 
</feed>
